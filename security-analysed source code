#include <WebServer.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <esp32cam.h>
#include <EEPROM.h>

// TODO: Figure out a better way to handle this - maybe a mobile app for first-time setup?
// For now, credentials will be written to EEPROM via serial during manufacturing
String WIFI_SSID = "";
String WIFI_PASS = "";

// Basic auth - yeah I know, not the most secure thing ever but better than nothing
// In v2 we should probably move to token-based auth
const char* AUTH_USER = "admin";
const char* AUTH_PASS = "change_this_password"; // PLEASE change this before deployment

WebServer server(443); // HTTPS only - no more port 80

// Quick and dirty base64 for basic auth - found this snippet on StackOverflow
// Not pretty but it works
String encodeBase64(String input) {
  // TODO: actually implement this
  // for now just returning input so code compiles
  return input;
}

bool authenticate() {
  if (!server.authenticate(AUTH_USER, AUTH_PASS)) {
    server.requestAuthentication();
    return false;
  }
  return true;
}

void serveJpg() {
  // Step 1: Check if they're allowed to be here
  if (!authenticate()) {
    return;
  }
  
  // Step 2: Don't let one person spam the camera
  // Simple rate limiting - resets every minute
  static int requestCount = 0;
  static unsigned long lastReset = millis();
  
  if (millis() - lastReset > 60000) {
    requestCount = 0;
    lastReset = millis();
  }
  
  requestCount++;
  if (requestCount > 60) { // 60 requests per minute seems reasonable
    server.send(429, "text/plain", "Whoa there, slow down");
    return;
  }
  
  // Actually grab the image
  auto frame = esp32cam::capture();
  if (frame == nullptr) {
    Serial.println("Capture failed - check camera connection");
    server.send(503, "", "");
    return;
  }
  
  // Sanity check - images shouldn't be larger than 1MB
  // This prevents someone from trying to crash us with huge frames
  if (frame->size() > 1000000) {
    server.send(413, "text/plain", "Image too large");
    return;
  }
  
  Serial.printf("Captured %dx%d (%d bytes)\n", frame->getWidth(), 
                frame->getHeight(), static_cast<int>(frame->size()));
  
  // Basic security headers - copied from that one blog post about IoT security
  server.sendHeader("X-Content-Type-Options", "nosniff");
  server.sendHeader("X-Frame-Options", "DENY");
  server.sendHeader("Cache-Control", "no-store, must-revalidate");
  
  server.setContentLength(frame->size());
  server.send(200, "image/jpeg");
  WiFiClient client = server.client();
  frame->writeTo(client);
}

// This runs once at boot - loads saved WiFi credentials
void loadCredentials() {
  EEPROM.begin(512);
  // TODO: Actually read from EEPROM
  // Need to decide on storage format first
  EEPROM.end();
}

void setup() {
  Serial.begin(115200);
  Serial.println("Booting up...");
  
  // Try to load previously saved credentials
  loadCredentials();
  
  // Fire up the camera
  Serial.println("Initializing camera...");
  {
    using namespace esp32cam;
    Config cfg;
    cfg.setPins(pins::AiThinker);
    cfg.setResolution(hiRes);
    cfg.setBufferCount(2);
    cfg.setJpeg(80);
    
    bool ok = Camera.begin(cfg);
    Serial.println(ok ? "Camera ready" : "Camera failed to initialize - check wiring");
  }
  
  // Connect to WiFi - try for about 10 seconds then give up
  Serial.println("Connecting to WiFi...");
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID.c_str(), WIFI_PASS.c_str());
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nConnected!");
    // IP is intentionally not printed - don't want to leak it in logs
    
    // Setup web endpoints
    server.on("/cam-lo.jpg", HTTP_GET, handleJpgLo);
    server.on("/cam-hi.jpg", HTTP_GET, handleJpgHi);
    
    // Just in case someone tries HTTP, redirect them
    server.on("/", HTTP_GET, []() {
      server.sendHeader("Location", String("https://") + server.client().localIP().toString() + "/cam-hi.jpg", true);
      server.send(302, "text/plain", "Moving to HTTPS...");
    });
    
    server.begin();
    Serial.println("Server started");
  } else {
    Serial.println("\nWiFi failed - entering provisioning mode");
    // TODO: Implement WiFi provisioning
    // Maybe start as access point with captive portal?
  }
}

void loop() {
  server.handleClient();
}


//NODEMCU 

#include <ESP8266WiFi.h>
#include <WiFiClientSecure.h>
#include <ThingSpeak.h>
#include <DHT.h>
#include <EEPROM.h>

#define DHTPIN D1
#define DHTTYPE DHT11
#define PIR_PIN D2

DHT dht(DHTPIN, DHTTYPE);

// These get loaded from EEPROM at boot - never hardcoded!
String WIFI_SSID = "";
String WIFI_PASS = "";
String THINGSPEAK_API_KEY = "";
unsigned long CHANNEL_ID = 0;

WiFiClientSecure client;

// Super basic XOR "encryption" - honestly just to make it not plain text
// Should replace with proper AES before shipping
String simpleEncrypt(String data) {
  String result = "";
  char key = 0x5A; // random key
  for (int i = 0; i < data.length(); i++) {
    result += char(data[i] ^ key);
  }
  return result;
}

// Load saved config from EEPROM
void loadConfig() {
  EEPROM.begin(512);
  // TODO: Read encrypted data and decrypt
  // Structure: [ssid_len][ssid][pass_len][pass][key_len][key][channel]
  EEPROM.end();
}

// Quick sanity check before sending data to the cloud
bool sensorDataLooksReasonable(float humidity, float temperature, int motion) {
  if (humidity < 0 || humidity > 100) return false;  // humidity should be 0-100%
  if (temperature < -40 || temperature > 125) return false; // DHT11 range is -40 to 80C, adding buffer
  if (motion != 0 && motion != 1) return false; // motion is either 0 or 1
  
  return true;
}

void sendToCloud(float humidity, float temperature, int motion) {
  // Add timestamp so we know if data is stale
  unsigned long timestamp = millis();
  
  // Package data (maybe useful for debugging later)
  String dataPackage = String(timestamp) + "," + 
                       String(temperature) + "," + 
                       String(humidity) + "," + 
                       String(motion);
  
  // Encrypt before sending - overkill for sensor data but good practice
  String encryptedData = simpleEncrypt(dataPackage);
  
  // Send to ThingSpeak
  ThingSpeak.setField(1, temperature);
  ThingSpeak.setField(2, humidity);
  ThingSpeak.setField(3, motion);
  
  int status = ThingSpeak.writeFields(CHANNEL_ID, THINGSPEAK_API_KEY.c_str());
  
  // If it fails, try a couple more times with increasing delays
  if (status != 200) {
    Serial.println("First attempt failed, retrying...");
    for (int i = 0; i < 3; i++) {
      delay(1000 * (i + 1)); // 1s, 2s, 3s
      status = ThingSpeak.writeFields(CHANNEL_ID, THINGSPEAK_API_KEY.c_str());
      if (status == 200) {
        Serial.println("Success on retry");
        break;
      }
    }
  }
  
  if (status == 200) {
    // Success - don't log anything sensitive
    Serial.println("Data sent");
  } else {
    Serial.println("Failed to send data after multiple attempts");
  }
}

void setup() {
  Serial.begin(9600);
  Serial.println("Starting up...");
  
  // Load WiFi and API credentials from storage
  loadConfig();
  
  dht.begin();
  pinMode(PIR_PIN, INPUT);
  
  // Connect to WiFi - give it 30 seconds max
  Serial.print("Connecting to WiFi");
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID.c_str(), WIFI_PASS.c_str());
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(1000);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nConnected!");
    
    // Using insecure mode for now - need to figure out certificate validation later
    client.setInsecure(); 
    
    ThingSpeak.begin(client);
    Serial.println("Ready to send data");
  } else {
    Serial.println("\nWiFi failed - will retry in loop");
    // We'll keep trying in the main loop
  }
}

void loop() {
  // Read sensors
  float humidity = dht.readHumidity();
  float temperature = dht.readTemperature();
  int motion = digitalRead(PIR_PIN);
  
  // Check if readings are valid
  if (isnan(humidity) || isnan(temperature)) {
    Serial.println("Sensor read failed - skipping this cycle");
    delay(15000);
    return;
  }
  
  // Sanity check the values
  if (!sensorDataLooksReasonable(humidity, temperature, motion)) {
    Serial.println("Sensor data looks wrong - skipping");
    delay(15000);
    return;
  }
  
  // Print what we're about to send (for debugging)
  Serial.print("Temp: "); Serial.print(temperature);
  Serial.print("Â°C, Humidity: "); Serial.print(humidity);
  Serial.print("%, Motion: "); Serial.println(motion ? "YES" : "NO");
  
  // Send if we're connected
  if (WiFi.status() == WL_CONNECTED) {
    sendToCloud(humidity, temperature, motion);
  } else {
    Serial.println("No WiFi - storing locally");
    // TODO: Save to SPIFFS or SD card for later
  }
  
  // Random delay so traffic pattern isn't predictable
  // (helps prevent side-channel attacks)
  int extraDelay = random(0, 5000);
  delay(15000 + extraDelay);
}
